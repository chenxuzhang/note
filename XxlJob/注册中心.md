```java
  官网给出的Spring项目执行器配置方式。
  只要将 XxlJobSpringExecutor 交给Spring管理并完善参数即可。
  @Bean
  public XxlJobSpringExecutor xxlJobExecutor() {
    XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor();
    xxlJobSpringExecutor.setAdminAddresses(adminAddresses);
    xxlJobSpringExecutor.setAppname(appname);
    xxlJobSpringExecutor.setIp(ip);
    xxlJobSpringExecutor.setPort(port);
    xxlJobSpringExecutor.setAccessToken(accessToken);
    xxlJobSpringExecutor.setLogPath(logPath);
    xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);
    return xxlJobSpringExecutor;
  }
```



## 服务注册

##### 执行器服务 上报 注册信息 到 调度器服务

代码调用栈

```java
执行器服务 启动的调用栈
1、XxlJobSpringExecutor.afterSingletonsInstantiated() // 由Spring管理bean的时候触发调用.XxlJobSpringExecutor 实现了 SmartInitializingSingleton 接口
 2、XxlJobExecutor.start()
  3、XxlJobExecutor.initAdminBizList(adminAddresses, accessToken) // adminAddresses 可配置多个 任务调度中心 地址,逗号隔开
   3.1、new AdminBizClient(address,accessToken) // 将 AdminBizClient 实例暂存到集合中,可通过 XxlJobExecutor.getAdminBizList() 访问
  4、XxlJobExecutor.initEmbedServer(address, ip, port, appname, accessToken)
   4.1、EmbedServer.start(address, port, appname, accessToken) // EmbedServer 内嵌的netty服务,用于接受调度器的指令
   4.2、EmbedServer.startRegistry(appname, address)
   4.3、ExecutorRegistryThread.start(final String appname, final String address) // ExecutorRegistryThread 执行器注册线程
   4.4、registryThread.run() // 注册服务线程,执行器服务如果正常,每30秒上报一次注册信息(节省了了心跳检测)
  
TODO adminAddresses 可配置多个 任务调度中心 地址,任务调度中心 集群化 支持？？？
TODO 为什么基于 SmartInitializingSingleton 接口拓展？？？


TODO initEmbedServer netty IP内网还是外网?默认获取的是内网ip,但是是可配置的
```

代码明细

```java
// 任务调度中心 地址处理
private void initAdminBizList(String adminAddresses, String accessToken) throws Exception {
  if (adminAddresses!=null && adminAddresses.trim().length()>0) {
   for (String address: adminAddresses.trim().split(",")) {
    if (address!=null && address.trim().length()>0) {
     // AdminBizClient 封装了对 任务调度中心的 http请求逻辑(含失败重试逻辑)
     AdminBiz adminBiz = new AdminBizClient(address.trim(), accessToken);
     if (adminBizList == null) {
       adminBizList = new ArrayList<AdminBiz>();
     }
     adminBizList.add(adminBiz);
    }
   }
  }
}

// EmbedServer 内嵌netty服务启动,用于接受 调度器 发来的指令,执行任务
public void start(final String address, final int port, final String appname, final String accessToken) {
 executorBiz = new ExecutorBizImpl();
 thread = new Thread(new Runnable() {
  @Override
  public void run() {
   ....
   // netty 启动服务绑定端口
   ChannelFuture future = bootstrap.bind(port).sync();
   // 执行器服务的注册逻辑。因为执行器注册后,就意味着要接受调度器的指令(netty接收指令),所以在 netty 服务启动后再进行执行器的注册
   startRegistry(appname, address);
  }
 });
 thread.setDaemon(true);
 thread.start();
}

// ExecutorRegistryThread 执行器 注册/注销(后续说) 服务线程
public void start(final String appname, final String address){
 registryThread = new Thread(new Runnable() {
  @Override
  public void run() {
   while (!toStop) { // toStop volatile 修饰的,可见性。当 执行器 服务正常关闭的时候,会将toStop置为true
    try { // RegistryParam 封装 注册请求参数。appname:{对应 xxl.job.executor.appname 的配置值} address:{ip}:{端口}
     RegistryParam registryParam = new RegistryParam(RegistryConfig.RegistType.EXECUTOR.name(), appname, address);
      // XxlJobExecutor.getAdminBizList() 用户获取 调用堆栈 3.1 步骤,已经实例化的 AdminBizClient 对象集合。
      // 它封装了对 任务调度中心的 http请求逻辑
      // for 循环,表示可以向任意多的 调度中心 发送注册 执行器服务 请求
      for (AdminBiz adminBiz: XxlJobExecutor.getAdminBizList()) {
       try {
        // registry 为封装好的http请求,对应的 调度器服务 接口名:{调度器域名}/api/registry
        ReturnT<String> registryResult = adminBiz.registry(registryParam);
        if (registryResult!=null && ReturnT.SUCCESS_CODE == registryResult.getCode()) {
         registryResult = ReturnT.SUCCESS;
         break;
        }
       } catch (Exception e) {
        logger.info(">>>>>>>>>>> xxl-job registry error, registryParam:{}", registryParam, e);
       }
      }
    } catch (Exception e) {
     if (!toStop) {
      logger.error(e.getMessage(), e);
     }
    }

    try {
     if (!toStop) { // 执行器服务正常,当前线程休眠30秒,然后进行下一轮的注册流程(注册(首次) + 维护心跳(后续))
      TimeUnit.SECONDS.sleep(RegistryConfig.BEAT_TIMEOUT);
     }
    } catch (InterruptedException e) {
     if (!toStop) {
      logger.warn(">>>>>>>>>>> xxl-job, executor registry thread interrupted, error msg:{}", e.getMessage());
     }
    }
  }

   // registry remove
   // 执行器 服务的注销逻辑。当 toStop 置为true的时候,才可以轮到注销逻辑执行
  }
 });
}
```



##### 调度器服务 处理上报的 注册信息

调用堆栈

```java
任务调度中心(调度器服务) 服务启动调用栈
1、XxlJobAdminConfig.afterPropertiesSet() // 由Spring管理bean的时候触发调用.XxlJobAdminConfig 实现了 InitializingBean 接口
 2、XxlJobScheduler.init()
  3、JobRegistryHelper.start() // 
   3.1、registryOrRemoveThreadPool = registryOrRemoveThreadPool = new ThreadPoolExecutor(...) // 处理 执行器服务 注册/注销 业务的线程池
   3.2、registryMonitorThread = new Thread() // 执行器服务 注册信息心跳检测(无效的就会从db删除)、维护执行器信息表(xxl_job_group)中的在线 执行器服务 地址
  
任务调度中心(调度器服务) 接收 执行器服务 http请求的调用栈(接口地址:api/registry)
1、JobApiController.api(...) // api/registry 接口
 2、AdminBizImpl.registry(...)
  3、JobRegistryHelper.registry(...)
   3.1、registryOrRemoveThreadPool.execute(new Runnable(){...}) // 执行器服务 注册/心跳 信息的 update 或 save
```

代码明细

```java
// 任务调度中心 服务启动后 针对注册中心监控的线程逻辑
registryMonitorThread = new Thread(new Runnable() {
 @Override
 public void run() {
  while (!toStop) { // 定时30秒检测一次(30秒一个心跳时间)
   try {
    // auto registry group 自动注册的分组
    List<XxlJobGroup> groupList = XxlJobAdminConfig.getAdminConfig().getXxlJobGroupDao().findByAddressType(0);
    if (groupList!=null && !groupList.isEmpty()) {
     // remove dead address (admin/executor) 
     // 心跳检测,超过3个心跳时间未进行心跳维护,就认为 执行器服务 挂了,需要定时清除
     List<Integer> ids = XxlJobAdminConfig.getAdminConfig().getXxlJobRegistryDao().findDead(RegistryConfig.DEAD_TIMEOUT, new Date());
     if (ids!=null && ids.size()>0) {
      XxlJobAdminConfig.getAdminConfig().getXxlJobRegistryDao().removeDead(ids); // 移除异常的 注册信息
     }

     // fresh online address (admin/executor)
     // 在线的 执行器服务 地址。key:执行器配置的 xxl.job.executor.appname 值,value:执行器服务的 ip:端口
     HashMap<String, List<String>> appAddressMap = new HashMap<String, List<String>>();
     // 查询出最近3个心跳时间注册或维护心跳的 执行器服务。前面是查询超过3个心跳时间未维护心跳的 执行器服务
     List<XxlJobRegistry> list = XxlJobAdminConfig.getAdminConfig().getXxlJobRegistryDao().findAll(RegistryConfig.DEAD_TIMEOUT, new Date()); 
     if (list != null) {
      for (XxlJobRegistry item: list) {
       if (RegistryConfig.RegistType.EXECUTOR.name().equals(item.getRegistryGroup())) {
        String appname = item.getRegistryKey();
        List<String> registryList = appAddressMap.get(appname);
        if (registryList == null) {
         registryList = new ArrayList<String>();
        }
        if (!registryList.contains(item.getRegistryValue())) {
         registryList.add(item.getRegistryValue());
        }
        appAddressMap.put(appname, registryList);
       }
      }
     }

     // fresh group address
     for (XxlJobGroup group: groupList) {
      List<String> registryList = appAddressMap.get(group.getAppname());
      String addressListStr = null;
      if (registryList!=null && !registryList.isEmpty()) {
       Collections.sort(registryList);
       StringBuilder addressListSB = new StringBuilder();
       for (String item:registryList) {
        addressListSB.append(item).append(",");
       }
       addressListStr = addressListSB.toString();
       addressListStr = addressListStr.substring(0, addressListStr.length()-1);
      }
      group.setAddressList(addressListStr);
      group.setUpdateTime(new Date());
      // 每隔30秒,才会主动拉取数据更新一次 执行器信息表 执行器服务地址,延时性问题
      XxlJobAdminConfig.getAdminConfig().getXxlJobGroupDao().update(group);
     }

    }
   } catch (Exception e) {
    if (!toStop) {
     logger.error(">>>>>>>>>>> xxl-job, job registry monitor thread error:{}", e);
    }
   }

   try {
    TimeUnit.SECONDS.sleep(RegistryConfig.BEAT_TIMEOUT); // 30秒,一个心跳时间
   } catch (InterruptedException e) {
    if (!toStop) {
     logger.error(">>>>>>>>>>> xxl-job, job registry monitor thread error:{}", e);
    }
   }
  }
 }
});
// 任务调度中心 接收 执行器服务 http请求 注册/心跳 信息处理
// 执行器服务 的注册信息 update 或 save
registryOrRemoveThreadPool.execute(new Runnable() { // 交给线程池进行异步处理
 @Override
 public void run() {
  // 心跳信息进行update,根据 registryGroup、registryKey、registryValue 为条件对 时间字段 更新。
  // 更新成功表示 心跳维护 正常
  int ret = XxlJobAdminConfig.getAdminConfig().getXxlJobRegistryDao().registryUpdate(registryParam.getRegistryGroup(), registryParam.getRegistryKey(), registryParam.getRegistryValue(), new Date());
  if (ret < 1) {
   // 第一次注册,会新增数据
   XxlJobAdminConfig.getAdminConfig().getXxlJobRegistryDao().registrySave(registryParam.getRegistryGroup(), registryParam.getRegistryKey(), registryParam.getRegistryValue(), new Date());

   // fresh
   reshGroupRegistryInfo(registryParam); // 其他业务,暂时未实现
  }
 }
});
```

## 服务注销



注销服务

​	执行器服务关闭(正常关闭) 上报注销信息

​	执行器异常关闭,调度器定时扫描注册信息 进行注销信息