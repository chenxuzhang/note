```java
  官网给出的Spring项目执行器配置方式。
  只要将 XxlJobSpringExecutor 交给Spring管理并完善参数即可。
  @Bean
  public XxlJobSpringExecutor xxlJobExecutor() {
    XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor();
    xxlJobSpringExecutor.setAdminAddresses(adminAddresses);
    xxlJobSpringExecutor.setAppname(appname);
    xxlJobSpringExecutor.setIp(ip);
    xxlJobSpringExecutor.setPort(port);
    xxlJobSpringExecutor.setAccessToken(accessToken);
    xxlJobSpringExecutor.setLogPath(logPath);
    xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);
    return xxlJobSpringExecutor;
  }
```



## 服务注册

##### 执行器服务 上报 注册信息 到 调度器服务

代码调用栈

```java
执行器服务 启动的调用栈
1、XxlJobSpringExecutor.afterSingletonsInstantiated() // 由Spring管理bean的时候触发调用.XxlJobSpringExecutor 实现了 SmartInitializingSingleton 接口
 2、XxlJobExecutor.start()
  3、XxlJobExecutor.initAdminBizList(adminAddresses, accessToken) // adminAddresses 可配置多个 任务调度中心 地址,逗号隔开
   3.1、new AdminBizClient(address,accessToken) // 将 AdminBizClient 实例暂存到集合中,可通过 XxlJobExecutor.getAdminBizList() 访问
  4、XxlJobExecutor.initEmbedServer(address, ip, port, appname, accessToken)
   4.1、EmbedServer.start(address, port, appname, accessToken) // EmbedServer 内嵌的netty服务,用于接受调度器的指令
   4.2、EmbedServer.startRegistry(appname, address)
   4.3、ExecutorRegistryThread.start(final String appname, final String address) // ExecutorRegistryThread 执行器注册线程
   4.4、registryThread.run() // 注册服务线程,执行器服务如果正常,每30秒上报一次注册信息(节省了了心跳检测)
  
TODO adminAddresses 可配置多个 任务调度中心 地址,任务调度中心 集群化 支持？？？
TODO 为什么基于 SmartInitializingSingleton 接口拓展？？？


TODO initEmbedServer netty IP内网还是外网?默认获取的是内网ip,但是是可配置的
```

代码明细

```java
// 任务调度中心 地址处理
private void initAdminBizList(String adminAddresses, String accessToken) throws Exception {
  if (adminAddresses!=null && adminAddresses.trim().length()>0) {
   for (String address: adminAddresses.trim().split(",")) {
    if (address!=null && address.trim().length()>0) {
     // AdminBizClient 封装了对 任务调度中心的 http请求逻辑(含失败重试逻辑)
     AdminBiz adminBiz = new AdminBizClient(address.trim(), accessToken);
     if (adminBizList == null) {
       adminBizList = new ArrayList<AdminBiz>();
     }
     adminBizList.add(adminBiz);
    }
   }
  }
}

// EmbedServer 内嵌netty服务启动,用于接受 调度器 发来的指令,执行任务
public void start(final String address, final int port, final String appname, final String accessToken) {
 executorBiz = new ExecutorBizImpl();
 thread = new Thread(new Runnable() {
  @Override
  public void run() {
   ....
   // netty 启动服务绑定端口
   ChannelFuture future = bootstrap.bind(port).sync();
   // 执行器服务的注册逻辑。因为执行器注册后,就意味着要接受调度器的指令(netty接收指令),所以在 netty 服务启动后再进行执行器的注册
   startRegistry(appname, address);
  }
 });
 thread.setDaemon(true);
 thread.start();
}

// ExecutorRegistryThread 执行器 注册/注销(后续说) 服务线程
public void start(final String appname, final String address){
 registryThread = new Thread(new Runnable() {
  @Override
  public void run() {
   while (!toStop) { // toStop volatile 修饰的,可见性。当 执行器 服务正常关闭的时候,会将toStop置为true
    try { // RegistryParam 封装 注册请求参数。appname:{对应 xxl.job.executor.appname 的配置值} address:{ip}:{端口}
     RegistryParam registryParam = new RegistryParam(RegistryConfig.RegistType.EXECUTOR.name(), appname, address);
      // XxlJobExecutor.getAdminBizList() 用户获取 调用堆栈 3.1 步骤,已经实例化的 AdminBizClient 对象集合。
      // 它封装了对 任务调度中心的 http请求逻辑
      // for 循环,表示可以向任意多的 调度中心 发送注册 执行器服务 请求
      for (AdminBiz adminBiz: XxlJobExecutor.getAdminBizList()) {
       try {
        // registry 为封装好的http请求,对应的 调度器服务 接口名:{调度器域名}/api/registry
        ReturnT<String> registryResult = adminBiz.registry(registryParam);
        if (registryResult!=null && ReturnT.SUCCESS_CODE == registryResult.getCode()) {
         registryResult = ReturnT.SUCCESS;
         break;
        }
       } catch (Exception e) {
        logger.info(">>>>>>>>>>> xxl-job registry error, registryParam:{}", registryParam, e);
       }
      }
    } catch (Exception e) {
     if (!toStop) {
      logger.error(e.getMessage(), e);
     }
    }

    try {
     if (!toStop) { // 执行器服务正常,当前线程休眠30秒,然后进行下一轮的注册流程(注册(首次) + 维护心跳(后续))
      TimeUnit.SECONDS.sleep(RegistryConfig.BEAT_TIMEOUT);
     }
    } catch (InterruptedException e) {
     if (!toStop) {
      logger.warn(">>>>>>>>>>> xxl-job, executor registry thread interrupted, error msg:{}", e.getMessage());
     }
    }
  }

   // registry remove
   // 执行器 服务的注销逻辑。当 toStop 置为true的时候,才可以轮到注销逻辑执行
  }
 });
}
```



##### 调度器服务 处理上报的 注册信息

调用堆栈

```java
任务调度中心(调度器服务) 服务启动调用栈
1、XxlJobAdminConfig.afterPropertiesSet() // 由Spring管理bean的时候触发调用.XxlJobAdminConfig 实现了 InitializingBean 接口
 2、XxlJobScheduler.init()
  3、JobRegistryHelper.start() // 
   3.1、registryOrRemoveThreadPool = registryOrRemoveThreadPool = new ThreadPoolExecutor(...) // 处理 执行器服务 注册/注销 业务的线程池
   3.2、registryMonitorThread = new Thread() // 执行器服务 注册信息心跳检测(无效的就会从db删除)、维护执行器信息表(xxl_job_group)中的在线 执行器服务 地址
  
任务调度中心(调度器服务) 接收 执行器服务 http请求的调用栈(接口地址:api/registry)
1、JobApiController.api(...) // api/registry 接口
 2、AdminBizImpl.registry(...)
  3、JobRegistryHelper.registry(...)
   3.1、registryOrRemoveThreadPool.execute(new Runnable(){...}) // 执行器服务 注册信息的 update 或 save
```

代码明细

```java

```

## 服务注销



注销服务

​	执行器服务关闭(正常关闭) 上报注销信息

​	执行器异常关闭,调度器定时扫描注册信息 进行注销信息