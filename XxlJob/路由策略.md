

##### 路由策略接口

```java
应用在 任务调度中心(调度器),当某个任务处于可调度状态的时候,任务调度中心 就会根据路由策略确定一个可用的 执行器服务地址

public abstract class ExecutorRouter {
 // triggerParam 封装的任务参数 
 // addressList 目前有效的且可用的 执行器服务地址,`xxl_job_registry` 表中 registry_value 字段值的解析数据
 // ReturnT<String> 返回的是经过路由策略逻辑确定下来的一个 执行器服务地址
 public abstract ReturnT<String> route(TriggerParam triggerParam, List<String> addressList);
}
```

##### 分片广播

```java

```



##### 第一个

```java
public class ExecutorRouteFirst extends ExecutorRouter {
 @Override
 public ReturnT<String> route(TriggerParam triggerParam, List<String> addressList){
  // 有效地可用的 执行器服务地址 中取数组下标为0的第一个地址
  return new ReturnT<String>(addressList.get(0));
 }
}
```

##### 最后一个

```java
public class ExecutorRouteLast extends ExecutorRouter {
 @Override
 public ReturnT<String> route(TriggerParam triggerParam, List<String> addressList) {
  // 有效地可用的 执行器服务地址 中取数组的最后一个地址
  return new ReturnT<String>(addressList.get(addressList.size()-1));
 }
}
```

##### 轮询

```java
public class ExecutorRouteRound extends ExecutorRouter {
 // jobId对应任务执行的次数 key:jobId value:任务执行的次数(任务执行时获取 执行器服务 地址 次数)
 private static ConcurrentMap<Integer, AtomicInteger> routeCountEachJob = new ConcurrentHashMap<>();
 private static long CACHE_VALID_TIME = 0;

  private static int count(int jobId) {
  // cache clear 缓存1天一清除,解决了问题???
  if (System.currentTimeMillis() > CACHE_VALID_TIME) {
   routeCountEachJob.clear();
   CACHE_VALID_TIME = System.currentTimeMillis() + 1000*60*60*24;
  }
  // 任务执行次数的累加,首次取随机值(目的是降低 执行器服务压力),后续每次累加1
  AtomicInteger count = routeCountEachJob.get(jobId);
  if (count == null || count.get() > 1000000) {
   // 初始化时主动Random一次,缓解首次压力,防止所有任务执行同时落到一台 执行器服务 上
   count = new AtomicInteger(new Random().nextInt(100));
  } else {
   // count++
   count.addAndGet(1);
  }
  routeCountEachJob.put(jobId, count);
  return count.get();
 }

 @Override
 public ReturnT<String> route(TriggerParam triggerParam, List<String> addressList) {
  // 任务执行次数 和 执行器服务地址 取模运算(最基础的轮询方式),得到的值从 执行器服务地址 中按照下标取
  // 问题1:调度器集群情况下,多台 任务调度中心(调度器) 进行任务调度的发起(应该是基于 `xxl_job_lock`表 "schedule_lock" 锁)
  // 问题2:addressList 数量经常变化 ???
  String address = addressList.get(count(triggerParam.getJobId())%addressList.size());
  return new ReturnT<String>(address);
 }
}
```

##### 随机

```java
public class ExecutorRouteRandom extends ExecutorRouter {
 private static Random localRandom = new Random();
 @Override
 public ReturnT<String> route(TriggerParam triggerParam, List<String> addressList) {
  // 随机数(执行器服务地址数量内取值),通过数组下标取 执行器服务地址
  String address = addressList.get(localRandom.nextInt(addressList.size()));
  return new ReturnT<String>(address);
 }
}
```

##### 一致性HASH

```java

```

##### 最不经常使用

```java

```

##### 最近最久未使用

```java

```

##### 故障转移

```java

```

##### 忙碌转移

```java

```

